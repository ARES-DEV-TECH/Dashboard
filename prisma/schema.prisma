// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url  	    = env("DATABASE_URL")
}

// Modèle utilisateur pour l'authentification
model User {
  id        String   @id @default(cuid())
  email     String   @unique
  password  String   // Hashé avec bcrypt
  firstName String?
  lastName  String?
  company   String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // Relations avec les données métier
  clients   Client[]
  articles  Article[]
  sales     Sale[]
  charges   Charge[]
  parameters ParametresEntreprise[]
  
  @@map("users")
}

model Client {
  userId     String
  clientName String
  firstName  String
  lastName   String
  email      String?
  phone      String?
  website    String?
  company    String?
  charges    Charge[] @relation("ChargeClient")
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([userId, clientName])
  @@index([email])
  @@index([userId])
  @@map("clients")
}

model Article {
  userId            String
  serviceName       String
  priceHt           Float
  billByHour        Boolean @default(false)
  billingFrequency  String?
  type              String?
  description       String?
  charges           Charge[] @relation("ChargeService")
  options           ServiceOption[]
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([userId, serviceName])
  @@index([userId])
  @@map("articles")
}

model ServiceOption {
  id          String @id @default(cuid())
  userId      String
  serviceName String
  name        String
  description String?
  priceHt     Float @default(0)
  isDefault   Boolean @default(false)
  article     Article @relation(fields: [userId, serviceName], references: [userId, serviceName], onDelete: Cascade)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@unique([userId, serviceName, name])
  @@index([userId, serviceName])
  @@map("service_options")
}

model Sale {
  userId       String
  invoiceNo    String
  saleDate     DateTime
  clientName   String
  serviceName  String
  quantity     Float    @default(1)   // nb heures si facturation à l'heure, sinon 1
  unitPriceHt  Float
  unitLabel    String?  // "heure" | "forfait" pour affichage PDF
  caHt         Float    // quantity * unitPriceHt
  tvaAmount    Float    // caHt * tauxTvaEntreprise/100
  totalTtc     Float    // caHt + tvaAmount
  options      String?  // JSON string des options sélectionnées
  year         Int
  quoteId      String?  // Reference to original quote
  invoiceId    String?  // Reference to invoice
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([userId, invoiceNo])

  // Relations optionnelles - les ventes peuvent exister sans client/article correspondant
  // client  Client  @relation(fields: [clientName], references: [clientName], onDelete: Cascade)
  // article Article @relation(fields: [serviceName], references: [serviceName], onDelete: Cascade)
  // Relations supprimées pour éviter les contraintes de clés étrangères
  // quote   Quote?  @relation(fields: [quoteId], references: [id], onDelete: SetNull)
  // invoice Invoice? @relation(fields: [invoiceId], references: [id], onDelete: SetNull)

  @@index([saleDate])
  @@index([clientName])
  @@index([serviceName])
  @@index([year])
  @@index([quoteId])
  @@index([invoiceId])
  @@index([userId])
  @@index([userId, saleDate]) // Requêtes dashboard/evolution par user + période
  @@index([userId, year])
  @@index([saleDate, year])
  @@index([clientName, serviceName])
  @@map("sales")
}

model Charge {
  id            String   @id @default(cuid())
  expenseDate   DateTime
  category      String?
  vendor        String?
  description   String?
  amount        Float?   // Montant TTC (renommé de amountTtc)
  recurring     Boolean?
  recurringType String? // "mensuel" | "annuel" | "ponctuel"
  paymentMethod String?
  notes         String?
  linkedService String?  // optional FK to Article.serviceName
  linkedSaleId  String?  // optional FK to Sale.invoiceNo
  linkedClient  String?  // optional FK to Client.clientName
  year          Int
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  // Relation avec l'utilisateur
  userId        String
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  article Article? @relation("ChargeService", fields: [userId, linkedService], references: [userId, serviceName], onDelete: SetNull)
  client  Client?  @relation("ChargeClient", fields: [userId, linkedClient], references: [userId, clientName], onDelete: SetNull)

  @@index([year])
  @@index([category])
  @@index([vendor])
  @@index([linkedService])
  @@index([linkedSaleId])
  @@index([linkedClient]) // Index pour les requêtes par client
  @@index([expenseDate])
  @@index([userId])
  @@index([userId, expenseDate]) // Requêtes breakdown/evolution par user + période
  @@index([userId, year])
  @@index([userId, recurring])
  @@index([year, category])
  @@index([expenseDate, year])
  @@map("charges")
}

model Quote {
  id            String   @id @default(cuid())
  quoteNo       String   @unique
  clientName    String
  clientEmail   String?
  clientAddress String?
  quoteDate     DateTime
  validUntil    DateTime
  items         String   // JSON string of QuoteItem[]
  notes         String?
  status        String   @default("draft") // "draft" | "sent" | "accepted" | "rejected" | "expired"
  totalHt       Float
  totalTva      Float
  totalTtc      Float
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Relations supprimées pour éviter les contraintes de clés étrangères
  // client   Client   @relation(fields: [clientName], references: [clientName], onDelete: Cascade)
  // sales    Sale[]   @relation
  // invoices Invoice[] @relation

  @@index([quoteNo])
  @@index([clientName])
  @@index([status])
  @@map("quotes")
}

model Invoice {
  id            String   @id @default(cuid())
  invoiceNo     String   @unique
  quoteId       String?  // Reference to original quote
  clientName    String
  clientEmail   String?
  clientAddress String?
  invoiceDate   DateTime
  dueDate       DateTime
  items         String   // JSON string of QuoteItem[]
  notes         String?
  paymentTerms  String?
  status        String   @default("draft") // "draft" | "sent" | "paid" | "overdue"
  totalHt       Float
  totalTva      Float
  totalTtc      Float
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Relations supprimées pour éviter les contraintes de clés étrangères
  // client Client  @relation(fields: [clientName], references: [clientName], onDelete: Cascade)
  // quote  Quote?  @relation(fields: [quoteId], references: [id], onDelete: SetNull)
  // sales  Sale[]  @relation

  @@index([invoiceNo])
  @@index([clientName])
  @@index([status])
  @@index([quoteId])
  @@map("invoices")
}

model ParametresEntreprise {
  userId String
  key    String
  value  String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([userId, key])
  @@index([userId])
  @@map("parametres_entreprise")
}